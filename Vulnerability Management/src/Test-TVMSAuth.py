"""
test_tvms_auth.py

Hard-coded smoke test for ACME TVMS:
- Reads certificate material from Azure Key Vault (Secret with same name as the Key Vault Certificate)
- Uses MSAL (client credentials with certificate) to get a token for Defender for Endpoint API
- Calls TVM vulnerabilities endpoint to validate auth and permissions

Notes:
- For Key Vault *Certificate* objects, the private key is exposed via a Secret of the same name,
  typically as a base64-encoded PFX (contentType: application/x-pkcs12).
- This script supports either:
  1) Secret contains PEM bundle (private key + cert), or
  2) Secret contains base64 PFX (optionally passworded)

Local prerequisites:
  pip install msal azure-identity azure-keyvault-secrets requests cryptography
  az login
"""

import base64
import json
import sys
from typing import Tuple

import requests
import msal
from azure.identity import DefaultAzureCredential
from azure.keyvault.secrets import SecretClient

from cryptography.hazmat.primitives.serialization import pkcs12, Encoding, PrivateFormat, NoEncryption
from cryptography.hazmat.primitives import hashes
from cryptography.x509 import load_pem_x509_certificate


# -------------------------
# HARD-CODED SETTINGS
# -------------------------
CONFIG = {
    # Key Vault URI (must end with a slash is fine either way)
    "kv_uri": "https://cts-ms-core-kv01.vault.azure.net/",

    # Tenant ID you are testing against (your partner tenant for the initial smoke test)
    "tenant_id": "b0b5dc70-6792-4ce8-8298-05a08d698d9d",

    # ACME TVMS Application (client) ID
    "client_id": "15fb699c-fbdf-47d8-86ab-e0fdb2feee12",

    # Name of the Key Vault Certificate or Secret that contains the private key material
    # If you created a KV Certificate named 'cert-acme-tvms', the Secret is typically also 'cert-acme-tvms'
    "cert_name": "cts-ms-tvms",

    # If the PFX in Key Vault is password protected, set it here. Otherwise leave as None.
    "pfx_password": None,
}


# Defender for Endpoint API scope + base URL
DEFENDER_SCOPE = "https://api.securitycenter.microsoft.com/.default"
DEFENDER_BASE = "https://api.securitycenter.microsoft.com"


# -------------------------
# KEY VAULT HELPERS
# -------------------------
def get_kv_secret(kv_uri: str, secret_name: str) -> str:
    """
    Reads a secret value from Key Vault using DefaultAzureCredential.
    For local dev, DefaultAzureCredential will use your az login session.
    """
    credential = DefaultAzureCredential(
        exclude_environment_credential=True,
        exclude_workload_identity_credential=True,
        exclude_managed_identity_credential=True,  # local runs, no IMDS
    )

    client = SecretClient(vault_url=kv_uri, credential=credential)
    secret = client.get_secret(secret_name)
    return secret.value


# -------------------------
# CERT PARSING HELPERS
# -------------------------
def pem_key_and_thumbprint_from_pfx_b64(pfx_b64: str, pfx_password: str | None = None) -> Tuple[str, str]:
    """
    Takes base64-encoded PFX bytes, extracts:
      - PEM encoded private key (PKCS8)
      - SHA1 thumbprint of the cert (hex)
    """
    pfx_bytes = base64.b64decode(pfx_b64)
    password_bytes = pfx_password.encode("utf-8") if pfx_password else None

    private_key, cert, _additional = pkcs12.load_key_and_certificates(pfx_bytes, password_bytes)
    if private_key is None or cert is None:
        raise RuntimeError(
            "Could not extract private key and certificate from PFX. "
            "If your PFX is passworded, set CONFIG['pfx_password']."
        )

    key_pem = private_key.private_bytes(
        encoding=Encoding.PEM,
        format=PrivateFormat.PKCS8,
        encryption_algorithm=NoEncryption(),
    ).decode("utf-8")

    cert_der = cert.public_bytes(Encoding.DER)
    digest = hashes.Hash(hashes.SHA1())
    digest.update(cert_der)
    thumbprint = digest.finalize().hex()

    return key_pem, thumbprint


def pem_key_and_thumbprint_from_pem_bundle(pem_text: str) -> Tuple[str, str]:
    """
    Expects a PEM string that contains at least:
      - a PRIVATE KEY block
      - a CERTIFICATE block
    """
    if "BEGIN PRIVATE KEY" not in pem_text and "BEGIN RSA PRIVATE KEY" not in pem_text:
        raise RuntimeError("PEM does not appear to contain a private key block.")

    if "BEGIN CERTIFICATE" not in pem_text:
        raise RuntimeError(
            "PEM does not contain a certificate block. Store a PEM that includes both "
            "the private key and the certificate."
        )

    cert_start = pem_text.find("-----BEGIN CERTIFICATE-----")
    cert_end = pem_text.find("-----END CERTIFICATE-----", cert_start)
    cert_block = pem_text[cert_start : cert_end + len("-----END CERTIFICATE-----")]

    cert_obj = load_pem_x509_certificate(cert_block.encode("utf-8"))
    cert_der = cert_obj.public_bytes(Encoding.DER)
    digest = hashes.Hash(hashes.SHA1())
    digest.update(cert_der)
    thumbprint = digest.finalize().hex()

    # Return the PEM as-is. MSAL will use the private key from the bundle.
    return pem_text, thumbprint


def get_private_key_and_thumbprint_from_keyvault(
    kv_uri: str,
    cert_name: str,
    pfx_password: str | None,
) -> Tuple[str, str]:
    """
    Reads the Key Vault secret value and determines whether it's PEM or base64 PFX.
    """
    value = get_kv_secret(kv_uri, cert_name)
    if value is None or not value.strip():
        raise RuntimeError(f"Key Vault secret '{cert_name}' returned empty content.")

    if value.strip().startswith("-----BEGIN"):
        return pem_key_and_thumbprint_from_pem_bundle(value)

    # Assume base64 PFX
    return pem_key_and_thumbprint_from_pfx_b64(value, pfx_password=pfx_password)


# -------------------------
# AUTH + API CALLS
# -------------------------
def acquire_defender_token(tenant_id: str, client_id: str, private_key_pem: str, thumbprint: str) -> str:
    authority = f"https://login.microsoftonline.com/{tenant_id}"

    app = msal.ConfidentialClientApplication(
        client_id=client_id,
        authority=authority,
        client_credential={
            "private_key": private_key_pem,
            "thumbprint": thumbprint,
        },
    )

    result = app.acquire_token_for_client(scopes=[DEFENDER_SCOPE])
    if "access_token" not in result:
        raise RuntimeError(f"Token acquisition failed: {json.dumps(result, indent=2)}")

    return result["access_token"]


def call_tvm_vulnerabilities(access_token: str) -> dict:
    """
    Calls Defender for Endpoint TVM vulnerabilities endpoint.
    Using $top=1 to keep the response small for a smoke test.
    """
    url = f"{DEFENDER_BASE}/api/vulnerabilities?$top=1"
    headers = {"Authorization": f"Bearer {access_token}"}

    r = requests.get(url, headers=headers, timeout=60)
    if r.status_code >= 400:
        raise RuntimeError(f"API call failed {r.status_code}: {r.text}")
    return r.json()


# -------------------------
# MAIN
# -------------------------
def main() -> int:
    kv_uri = CONFIG["kv_uri"]
    tenant_id = CONFIG["tenant_id"]
    client_id = CONFIG["client_id"]
    cert_name = CONFIG["cert_name"]
    pfx_password = CONFIG.get("pfx_password")

    if "<your-" in kv_uri or "<your-" in tenant_id or "<acme-" in client_id:
        raise RuntimeError(
            "Update the CONFIG dictionary at the top of the script with your real values "
            "before running."
        )

    private_key_pem, thumbprint = get_private_key_and_thumbprint_from_keyvault(kv_uri, cert_name, pfx_password)
    token = acquire_defender_token(tenant_id, client_id, private_key_pem, thumbprint)
    data = call_tvm_vulnerabilities(token)

    items = data.get("value", [])
    print(f"Success. Returned {len(items)} vulnerability record(s).")

    if items:
        first = items[0]
        print("Sample vulnerability id:", first.get("id"))
        # Print a few keys to confirm shape without dumping everything
        print("Sample keys:", list(first.keys())[:12])

    return 0


if __name__ == "__main__":
    try:
        raise SystemExit(main())
    except Exception as e:
        print(f"Failed: {e}", file=sys.stderr)
        raise
